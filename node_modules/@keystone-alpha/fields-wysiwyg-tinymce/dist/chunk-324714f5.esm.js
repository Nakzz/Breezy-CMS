import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { Global, css, jsx } from '@emotion/core';
import React, { useRef, useEffect, Component } from 'react';
import { FieldContainer, FieldLabel } from '@arch-ui/fields';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread';
import _taggedTemplateLiteral from '@babel/runtime/helpers/esm/taggedTemplateLiteral';
import PropTypes from 'prop-types';
import tinymce from 'tinymce/tinymce';

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n      .tox-tinymce {\n        border-radius: 5px !important;\n        border-color: #c1c7d0 !important;\n      }\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

tinymce.baseURL = '/tinymce-assets';
const defaultOptions = {
  autoresize_bottom_margin: 20,
  branding: false,
  menubar: false,
  statusbar: false,
  quickbars_selection_toolbar: 'bold italic underline strikethrough | h1 h2 h3 | quicklink blockquote removeformat',
  quickbars_insert_toolbar: false
};
const defaultPlugins = 'link lists code autoresize paste textcolor quickbars hr table emoticons image';
const defaultToolbar = 'formatselect forecolor | alignleft aligncenter alignright alignjustify | bullist numlist indent outdent | link unlink | image table emoticons hr | code'; // The GlobalStyles component overrides some of the TinyMCE theme
// to better match the Admin UI style

const GlobalStyles = () => React.createElement(Global, {
  styles: css(_templateObject())
});

const Editor = props => {
  const value = props.value,
        name = props.name,
        isDisabled = props.isDisabled,
        autoFocus = props.autoFocus,
        plugins = props.plugins,
        toolbar = props.toolbar;
  const elementRef = useRef(null);
  const editorRef = useRef(null);
  const contentRef = useRef(value);

  const editorIsReady = () => editorRef.current && editorRef.current.initialized;

  const handleChange = () => {
    const onChange = props.onChange;
    const content = editorRef.current.getContent();
    if (contentRef.current === content) return;
    contentRef.current = content;

    if (typeof onChange === 'function') {
      onChange(content);
    }
  }; // Set up the Editor


  useEffect(() => {
    // TODO: allow additional options to be mixed in
    const options = _objectSpread({}, defaultOptions, {
      auto_focus: autoFocus,
      plugins: plugins || defaultPlugins,
      readonly: isDisabled,
      target: elementRef.current,
      toolbar: toolbar || defaultToolbar,
      setup: editor => {
        editorRef.current = editor;
        editor.on('init', () => {
          if (typeof value === 'string') {
            editor.setContent(value);
          }

          editor.on('change keyup setcontent', handleChange);
        });
      }
    });

    tinymce.init(options);
    return () => {
      tinymce.remove(editorRef.current);
    };
  }, [plugins, toolbar]); // Update the Editor content when the value prop changes

  useEffect(() => {
    if (!editorIsReady() || typeof value !== 'string' || value === contentRef.current) return;
    editorRef.current.setContent(value);
  }, [value]); // Update the Editor mode when the isDisabled prop changes

  useEffect(() => {
    if (!editorIsReady()) return;
    editorRef.current.setMode(isDisabled ? 'readonly' : 'design');
  }, [isDisabled, editorRef.current]);
  return React.createElement(React.Fragment, null, React.createElement(GlobalStyles, null), React.createElement("textarea", {
    ref: elementRef,
    style: {
      visibility: 'hidden',
      width: '100%'
    },
    name: name
  }));
};

Editor.propTypes = {
  autoFocus: PropTypes.bool,
  isDisabled: PropTypes.bool,
  name: PropTypes.string,
  onChange: PropTypes.func,
  plugins: PropTypes.array,
  toolbar: PropTypes.array,
  value: PropTypes.string
};

class WysiwygField extends Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onChange", value => {
      if (typeof value === 'string' && value !== this.props.value) {
        this.props.onChange(value);
      }
    });
  }

  render() {
    const _this$props = this.props,
          autoFocus = _this$props.autoFocus,
          field = _this$props.field,
          errors = _this$props.errors,
          serverValue = _this$props.value;
    const value = serverValue || '';
    const htmlID = "ks-input-".concat(field.path);
    const accessError = errors.find(error => error instanceof Error && error.name === 'AccessDeniedError');
    if (accessError) return null;
    return jsx(FieldContainer, null, jsx(FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), jsx("div", {
      css: {
        display: 'flex',
        flex: 1
      }
    }, jsx(Editor, {
      value: value,
      onChange: this.onChange,
      id: htmlID,
      autoFocus: autoFocus
    })));
  }

}

export default WysiwygField;
