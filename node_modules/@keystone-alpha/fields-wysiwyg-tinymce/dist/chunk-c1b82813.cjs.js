'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty"));

var core = require('@emotion/core');

var React = require('react');

var React__default = _interopDefault(React);

var fields = require('@arch-ui/fields');

var _objectSpread = _interopDefault(require("@babel/runtime/helpers/objectSpread"));

var _taggedTemplateLiteral = _interopDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var PropTypes = _interopDefault(require('prop-types'));

var tinymce = _interopDefault(require('tinymce/tinymce'));

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n      .tox-tinymce {\n        border-radius: 5px !important;\n        border-color: #c1c7d0 !important;\n      }\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

tinymce.baseURL = '/tinymce-assets';
const defaultOptions = {
  autoresize_bottom_margin: 20,
  branding: false,
  menubar: false,
  statusbar: false,
  quickbars_selection_toolbar: 'bold italic underline strikethrough | h1 h2 h3 | quicklink blockquote removeformat',
  quickbars_insert_toolbar: false
};
const defaultPlugins = 'link lists code autoresize paste textcolor quickbars hr table emoticons image';
const defaultToolbar = 'formatselect forecolor | alignleft aligncenter alignright alignjustify | bullist numlist indent outdent | link unlink | image table emoticons hr | code'; // The GlobalStyles component overrides some of the TinyMCE theme
// to better match the Admin UI style

const GlobalStyles = () => React__default.createElement(core.Global, {
  styles: core.css(_templateObject())
});

const Editor = props => {
  const value = props.value,
        name = props.name,
        isDisabled = props.isDisabled,
        autoFocus = props.autoFocus,
        plugins = props.plugins,
        toolbar = props.toolbar;
  const elementRef = React.useRef(null);
  const editorRef = React.useRef(null);
  const contentRef = React.useRef(value);

  const editorIsReady = () => editorRef.current && editorRef.current.initialized;

  const handleChange = () => {
    const onChange = props.onChange;
    const content = editorRef.current.getContent();
    if (contentRef.current === content) return;
    contentRef.current = content;

    if (typeof onChange === 'function') {
      onChange(content);
    }
  }; // Set up the Editor


  React.useEffect(() => {
    // TODO: allow additional options to be mixed in
    const options = _objectSpread({}, defaultOptions, {
      auto_focus: autoFocus,
      plugins: plugins || defaultPlugins,
      readonly: isDisabled,
      target: elementRef.current,
      toolbar: toolbar || defaultToolbar,
      setup: editor => {
        editorRef.current = editor;
        editor.on('init', () => {
          if (typeof value === 'string') {
            editor.setContent(value);
          }

          editor.on('change keyup setcontent', handleChange);
        });
      }
    });

    tinymce.init(options);
    return () => {
      tinymce.remove(editorRef.current);
    };
  }, [plugins, toolbar]); // Update the Editor content when the value prop changes

  React.useEffect(() => {
    if (!editorIsReady() || typeof value !== 'string' || value === contentRef.current) return;
    editorRef.current.setContent(value);
  }, [value]); // Update the Editor mode when the isDisabled prop changes

  React.useEffect(() => {
    if (!editorIsReady()) return;
    editorRef.current.setMode(isDisabled ? 'readonly' : 'design');
  }, [isDisabled, editorRef.current]);
  return React__default.createElement(React__default.Fragment, null, React__default.createElement(GlobalStyles, null), React__default.createElement("textarea", {
    ref: elementRef,
    style: {
      visibility: 'hidden',
      width: '100%'
    },
    name: name
  }));
};

Editor.propTypes = {
  autoFocus: PropTypes.bool,
  isDisabled: PropTypes.bool,
  name: PropTypes.string,
  onChange: PropTypes.func,
  plugins: PropTypes.array,
  toolbar: PropTypes.array,
  value: PropTypes.string
};

class WysiwygField extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onChange", value => {
      if (typeof value === 'string' && value !== this.props.value) {
        this.props.onChange(value);
      }
    });
  }

  render() {
    const _this$props = this.props,
          autoFocus = _this$props.autoFocus,
          field = _this$props.field,
          errors = _this$props.errors,
          serverValue = _this$props.value;
    const value = serverValue || '';
    const htmlID = "ks-input-".concat(field.path);
    const accessError = errors.find(error => error instanceof Error && error.name === 'AccessDeniedError');
    if (accessError) return null;
    return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), core.jsx("div", {
      css: {
        display: 'flex',
        flex: 1
      }
    }, core.jsx(Editor, {
      value: value,
      onChange: this.onChange,
      id: htmlID,
      autoFocus: autoFocus
    })));
  }

}

exports.default = WysiwygField;
