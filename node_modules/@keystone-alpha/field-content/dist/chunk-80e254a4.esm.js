import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import '@babel/runtime/helpers/esm/objectWithoutProperties';
import _extends from '@babel/runtime/helpers/esm/extends';
import { jsx } from '@emotion/core';
import { LinkExternalIcon, LinkIcon, CheckIcon, CircleSlashIcon } from '@arch-ui/icons';
import { gridSize, colors } from '@arch-ui/theme';
import '@arch-ui/color-utils';
import '@arch-ui/tooltip';
import '@arch-ui/typography';
import { a as ToolbarButton } from './chunk-31fbf0c2.esm.js';
import React__default, { useState, useEffect, Fragment, useContext } from 'react';
import { Popper } from 'react-popper';
import { createPortal } from 'react-dom';
let type = 'link';

function Node(_ref) {
  let node = _ref.node,
      attributes = _ref.attributes,
      children = _ref.children,
      isSelected = _ref.isSelected,
      editor = _ref.editor;
  let data = node.data;
  const href = data.get('href');

  let _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      aElement = _useState2[0],
      setAElement = _useState2[1];

  let _useState3 = useState(href),
      _useState4 = _slicedToArray(_useState3, 2),
      linkInputValue = _useState4[0],
      setLinkInputValue = _useState4[1]; // this is terrible
  // but probably necessary
  // because if we just do editor.setNodeByKey in the input onChange
  // and let that change propagate the cursor position breaks


  useEffect(() => {
    setLinkInputValue(href);
  }, [href]);
  return jsx(Fragment, null, jsx("a", _extends({}, attributes, {
    ref: setAElement,
    css: {
      color: 'blue',
      ':visited': {
        color: 'purple'
      }
    },
    href: href
  }), children), isSelected && createPortal(jsx(Popper, {
    placement: "bottom",
    referenceElement: aElement
  }, _ref2 => {
    let style = _ref2.style,
        ref = _ref2.ref;
    return jsx("div", {
      style: style,
      css: {
        margin: gridSize,
        display: 'flex'
      }
    }, jsx("div", {
      ref: ref,
      css: {
        backgroundColor: colors.N90,
        color: 'white',
        padding: 8,
        borderRadius: 6,
        display: 'flex'
      }
    }, jsx(LinkInput, {
      value: linkInputValue,
      onChange: event => {
        setLinkInputValue(event.target.value);
        editor.setNodeByKey(node.key, {
          data: data.set('href', event.target.value)
        });
      }
    }), jsx(ToolbarButton, {
      as: "a",
      tooltipPlacement: "bottom",
      icon: jsx(LinkExternalIcon, null),
      target: "_blank",
      rel: "noopener",
      label: "Open Link",
      css: {
        marginLeft: gridSize
      },
      href: href
    })));
  }), document.body));
}

function LinkInput(props) {
  return jsx("input", _extends({
    placeholder: "Link...",
    css: {
      border: 0,
      outline: 'none',
      background: 'transparent',
      color: 'white'
    }
  }, props));
}

let SetLinkRange = React__default.createContext(() => {});

let LinkMenu = props => {
  let _useState5 = useState(''),
      _useState6 = _slicedToArray(_useState5, 2),
      value = _useState6[0],
      setValue = _useState6[1];

  return jsx("form", {
    onSubmit: e => {
      e.stopPropagation();
      e.preventDefault();
      props.onSubmit(value);
    },
    css: {
      display: 'flex'
    }
  }, jsx(LinkInput, {
    autoFocus: true,
    value: value,
    onChange: e => {
      setValue(e.target.value);
    }
  }), jsx(ToolbarButton, {
    label: "Submit",
    icon: jsx(CheckIcon, null),
    type: "submit"
  }), jsx(ToolbarButton, {
    label: "Cancel",
    icon: jsx(CircleSlashIcon, null),
    onClick: () => {
      props.onCancel();
    }
  }));
};

function Toolbar(_ref3) {
  let children = _ref3.children,
      editor = _ref3.editor;

  let _useState7 = useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      linkRange = _useState8[0],
      setLinkRange = _useState8[1];

  return jsx(SetLinkRange.Provider, {
    value: setLinkRange
  }, linkRange === null ? children : jsx(LinkMenu, {
    onSubmit: value => {
      editor.wrapInlineAtRange(linkRange, {
        type: type,
        data: {
          href: value
        }
      });
      editor.deselect();
    },
    onCancel: () => {
      setLinkRange(null);
    }
  }));
}

function ToolbarElement(_ref4) {
  let editor = _ref4.editor,
      editorState = _ref4.editorState;
  let hasLinks = editorState.inlines.some(inline => inline.type === type);
  let setLinkRange = useContext(SetLinkRange);
  return jsx(ToolbarButton, {
    isActive: hasLinks,
    label: hasLinks ? 'Remove Link' : 'Link',
    icon: jsx(LinkIcon, null),
    onClick: () => {
      if (hasLinks) {
        editor.unwrapInline(type);
      } else {
        setLinkRange(editorState.selection);
      }
    }
  });
}

export { type, Node, Toolbar, ToolbarElement };
