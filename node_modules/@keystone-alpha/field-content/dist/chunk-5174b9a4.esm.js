import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _extends from '@babel/runtime/helpers/esm/extends';
import { jsx } from '@emotion/core';
import { forwardRef, useLayoutEffect, createContext, useContext } from 'react';
import { Popper } from 'react-popper';
import { a as useStateWithEqualityCheck } from './chunk-ffc6d47c.esm.js';
let PopperRender = forwardRef((_ref, ref) => {
  let scheduleUpdate = _ref.scheduleUpdate,
      alignment = _ref.alignment,
      isFocused = _ref.isFocused,
      style = _ref.style,
      onAlignmentChange = _ref.onAlignmentChange;
  useLayoutEffect(scheduleUpdate, [alignment]);
  return jsx("div", {
    ref: ref,
    css: {
      display: isFocused ? 'block' : 'none',
      backgroundColor: 'black',
      padding: 8
    },
    style: style
  }, ['left', 'center', 'right'].map(align => {
    return jsx("button", {
      type: "button",
      key: align,
      onMouseDown: event => {
        // so that the image block doesn't get deselected
        event.preventDefault();
      },
      onClick: () => {
        onAlignmentChange(align);
      }
    }, align);
  }));
});
let popperModifiers = {
  flip: {
    enabled: false
  },
  hide: {
    enabled: false
  },
  preventOverflow: {
    enabled: false
  }
};

let Image = _ref2 => {
  let alignment = _ref2.alignment,
      attributes = _ref2.attributes,
      isFocused = _ref2.isFocused,
      src = _ref2.src,
      onAlignmentChange = _ref2.onAlignmentChange,
      props = _objectWithoutProperties(_ref2, ["alignment", "attributes", "isFocused", "src", "onAlignmentChange"]);

  let _useStateWithEquality = useStateWithEqualityCheck(null),
      _useStateWithEquality2 = _slicedToArray(_useStateWithEquality, 2),
      referenceElement = _useStateWithEquality2[0],
      setReferenceElement = _useStateWithEquality2[1];

  return jsx("div", null, jsx("img", _extends({}, props, attributes, {
    src: src,
    ref: setReferenceElement,
    css: {
      width: '100%',
      outline: isFocused ? 'auto' : null
    }
  })), jsx(Popper, {
    modifiers: popperModifiers,
    placement: "top",
    referenceElement: referenceElement
  }, _ref3 => {
    let style = _ref3.style,
        ref = _ref3.ref,
        scheduleUpdate = _ref3.scheduleUpdate;
    return jsx(PopperRender, {
      scheduleUpdate,
      alignment,
      ref,
      isFocused,
      style,
      onAlignmentChange
    });
  }));
};
/** @jsx jsx */


let type = 'image';
let ImageAlignmentContext = createContext({
  aligment: '',

  onAlignmentChange() {}

});

function Node(props) {
  let data = props.node.data;

  let _React$useContext = useContext(ImageAlignmentContext),
      aligment = _React$useContext.aligment,
      onAlignmentChange = _React$useContext.onAlignmentChange;

  return jsx(Image, {
    alignment: aligment,
    attributes: props.attributes,
    isFocused: props.isFocused,
    src: data.get('src'),
    onAlignmentChange: onAlignmentChange
  });
}

let getSchema = () => ({
  isVoid: true
});

export { type, ImageAlignmentContext, Node, getSchema };
